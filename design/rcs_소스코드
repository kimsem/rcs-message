// settings.gradle
rootProject.name = 'rcs-portal'

include 'common'
include 'auth-service'
include 'message-service'
include 'history-service'
include 'basedata-service'


// build.gradle
plugins {
    id 'org.springframework.boot' version '3.2.3'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'java'
}

allprojects {
    apply plugin: 'java'
    apply plugin: 'jacoco'
    
    group = 'com.ktds.rcsp'
    version = '1.0.0'
    sourceCompatibility = '17'
    
    repositories {
        mavenCentral()
    }
    
    test {
        useJUnitPlatform()
    }
}

subprojects {
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'
    
    dependencies {
        // Spring Boot
        implementation 'org.springframework.boot:spring-boot-starter-web'
        implementation 'org.springframework.boot:spring-boot-starter-validation'
        implementation 'org.springframework.boot:spring-boot-starter-actuator'
        
        // Swagger
        implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.3.0'
        
        // Database
        implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
        runtimeOnly 'org.postgresql:postgresql'
        
        // Security
        implementation 'org.springframework.boot:spring-boot-starter-security'
        
        // Cache
        implementation 'org.springframework.boot:spring-boot-starter-cache'
        
        // Lombok
        compileOnly 'org.projectlombok:lombok'
        annotationProcessor 'org.projectlombok:lombok'
        
        // Testing
        testImplementation 'org.springframework.boot:spring-boot-starter-test'
        testImplementation 'org.springframework.security:spring-security-test'
        testImplementation 'org.testcontainers:junit-jupiter'
        testImplementation 'org.testcontainers:postgresql'
    }
}

// common/build.gradle

bootJar { enabled = false }
jar { enabled = true }

dependencies {
    api 'org.springframework.boot:spring-boot-starter-aop'
    api 'com.fasterxml.jackson.core:jackson-databind'
    api 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'
}

// auth-service/build.gradle
dependencies {
    implementation project(':common')
}

// message-service/build.gradle
dependencies {
    implementation project(':common')
    implementation 'com.azure:azure-messaging-eventhubs:5.15.0'
    implementation 'org.apache.commons:commons-csv:1.10.0'
}

//history-service/build.gradle
dependencies {
    implementation project(':common')
}

// basedata-service/build.gradle]
dependencies {
    implementation project(':common')
}

# Application Properties
// common/application.yml
spring:
  application:
    name: common

logging:
  level:
    com.ktds.rcsp: DEBUG

// auth-service/application.yml
spring:
  application:
    name: auth-service
  datasource:
    url: ${AUTH_DB_URL}
    username: ${AUTH_DB_USERNAME}
    password: ${AUTH_DB_PASSWORD}
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: true
    
server:
  port: 8081

jwt:
  secret: ${JWT_SECRET}
  expiration: 1800000

// message-service/application.yml
spring:
  application:
    name: message-service
  datasource:
    url: ${MESSAGE_DB_URL}
    username: ${MESSAGE_DB_USERNAME}
    password: ${MESSAGE_DB_PASSWORD}
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: true
    
server:
  port: 8082

azure:
  eventhub:
    connection-string: ${EVENTHUB_CONNECTION_STRING}
    name: ${EVENTHUB_NAME}

// history-service/application.yml
spring:
  application:
    name: history-service
  datasource:
    url: ${HISTORY_DB_URL}
    username: ${HISTORY_DB_USERNAME}
    password: ${HISTORY_DB_PASSWORD}
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: true
    
server:
  port: 8083

// basedata-service/application.yml
spring:
  application:
    name: basedata-service
  datasource:
    url: ${BASEDATA_DB_URL}
    username: ${BASEDATA_DB_USERNAME}
    password: ${BASEDATA_DB_PASSWORD}
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: true
    
server:
  port: 8084


// common/src/main/java/com/ktds/rcsp/common/config/SwaggerConfig.java
package com.ktds.rcsp.common.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {
    
    @Bean
    public OpenAPI openAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("RCS Portal API")
                        .description("RCS Portal API 문서")
                        .version("1.0.0"));
    }
}

// common/src/main/java/com/ktds/rcsp/common/config/AsyncConfig.java
package com.ktds.rcsp.common.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix("RcsAsync-");
        executor.initialize();
        return executor;
    }
}

// common/src/main/java/com/ktds/rcsp/common/dto/ApiResponse.java
package com.ktds.rcsp.common.dto;

import lombok.Getter;
import java.time.LocalDateTime;

@Getter
public class ApiResponse<T> {
    private final int status;
    private final String message;
    private final T data;
    private final LocalDateTime timestamp;

    private ApiResponse(int status, String message, T data) {
        this.status = status;
        this.message = message;
        this.data = data;
        this.timestamp = LocalDateTime.now();
    }

    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(200, "Success", data);
    }

    public static <T> ApiResponse<T> error(int status, String message) {
        return new ApiResponse<>(status, message, null);
    }
}

// common/src/main/java/com/ktds/rcsp/common/dto/PageResponse.java
package com.ktds.rcsp.common.dto;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import java.util.List;

@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PageResponse<T> {
    private List<T> content;
    private long totalElements;
    private int totalPages;
    private int pageNumber;
    private int pageSize;
}

// common/src/main/java/com/ktds/rcsp/common/exception/BusinessException.java
package com.ktds.rcsp.common.exception;

public class BusinessException extends RuntimeException {
    public BusinessException(String message) {
        super(message);
    }

    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}

// common/src/main/java/com/ktds/rcsp/common/exception/GlobalExceptionHandler.java
package com.ktds.rcsp.common.exception;

import com.ktds.rcsp.common.dto.ApiResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ApiResponse<Void> handleBusinessException(BusinessException e) {
        log.error("Business exception occurred: ", e);
        return ApiResponse.error(HttpStatus.BAD_REQUEST.value(), e.getMessage());
    }

    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ApiResponse<Void> handleException(Exception e) {
        log.error("Unexpected exception occurred: ", e);
        return ApiResponse.error(HttpStatus.INTERNAL_SERVER_ERROR.value(), "Internal server error");
    }
}

// common/src/main/java/com/ktds/rcsp/common/event/MessageEventPublisher.java
package com.ktds.rcsp.common.event;

/**
 * RCS 메시지 이벤트 발행을 위한 인터페이스
 */
public interface MessageEventPublisher {
    void publishUploadEvent(RecipientUploadEvent event);
    void publishSendEvent(MessageSendEvent event);
    void publishResultEvent(MessageResultEvent event);
}

// common/src/main/java/com/ktds/rcsp/common/event/MessageEventSubscriber.java
package com.ktds.rcsp.common.event;

/**
 * RCS 메시지 이벤트 구독을 위한 인터페이스
 */
public interface MessageEventSubscriber {
    void subscribeToUploadEvents();
    void subscribeToSendEvents();
    void subscribeToResultEvents();
}

// common/src/main/java/com/ktds/rcsp/common/event/EventType.java
package com.ktds.rcsp.common.event;

public enum EventType {
    RECIPIENT_UPLOAD,    // 수신자 정보 업로드
    MESSAGE_SEND,       // 메시지 발송
    MESSAGE_RESULT      // 메시지 발송 결과
}

// common/src/main/java/com/ktds/rcsp/common/event/Event.java
package com.ktds.rcsp.common.event;

import lombok.Getter;
import java.time.LocalDateTime;
import java.util.UUID;

@Getter
public abstract class Event {
     private final String eventId;
    private final LocalDateTime timestamp;
    private final EventType eventType;

    protected Event(EventType eventType) {
        this.eventId = UUID.randomUUID().toString();
        this.timestamp = LocalDateTime.now();
        this.eventType = eventType;
    }
}

// common/src/main/java/com/ktds/rcsp/common/event/RecipientUploadEvent.java
package com.ktds.rcsp.common.event;

import lombok.Builder;
import lombok.Getter;

@Getter
public class RecipientUploadEvent extends Event {
    private final String messageGroupId;
    private final String fileName;
    private final int totalCount;
    
    @Builder
    public RecipientUploadEvent(String messageGroupId, String fileName, int totalCount) {
        super(EventType.RECIPIENT_UPLOAD);
        this.messageGroupId = messageGroupId;
        this.fileName = fileName;
        this.totalCount = totalCount;
    }
}

// common/src/main/java/com/ktds/rcsp/common/event/MessageSendEvent.java
package com.ktds.rcsp.common.event;

import lombok.Builder;
import lombok.Getter;

@Getter
public class MessageSendEvent extends Event {
    private final String messageId;
    private final String messageGroupId;
    private final String content;
    private final String recipientPhone;
    
    @Builder
    public MessageSendEvent(String messageId, String messageGroupId, String content, String recipientPhone) {
        super(EventType.MESSAGE_SEND);
        this.messageId = messageId;
        this.messageGroupId = messageGroupId;
        this.content = content;
        this.recipientPhone = recipientPhone;
    }
}

// common/src/main/java/com/ktds/rcsp/common/event/MessageResultEvent.java
package com.ktds.rcsp.common.event;

import lombok.Builder;
import lombok.Getter;

@Getter
public class MessageResultEvent extends Event {
    private final String messageId;
    private final String status;
    private final String resultCode;
    private final String resultMessage;
    
    @Builder
    public MessageResultEvent(String messageId, String status, String resultCode, String resultMessage) {
        super(EventType.MESSAGE_RESULT);
        this.messageId = messageId;
        this.status = status;
        this.resultCode = resultCode;
        this.resultMessage = resultMessage;
    }
}

// auth-service/src/main/java/com/ktds/rcsp/auth/AuthServiceApplication.java
package com.ktds.rcsp.auth;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = {"com.ktds.rcsp.auth", "com.ktds.rcsp.common"})
public class AuthServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthServiceApplication.class, args);
    }
}

// auth-service/src/main/java/com/ktds/rcsp/auth/domain/User.java
package com.ktds.rcsp.auth.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

@Entity
@Table(name = "users")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    @Id
    @Column(name = "user_id")
    private String userId;
    
    @Column(name = "master_id", nullable = false)
    private String masterId;
    
    @Column(nullable = false)
    private String password;
    
    @Column(nullable = false)
    private String status;
    
    @Column(name = "login_attempt")
    private int loginAttempt;
}

// auth-service/src/main/java/com/ktds/rcsp/auth/dto/LoginRequest.java
package com.ktds.rcsp.auth.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Schema(description = "로그인 요청")
public class LoginRequest {
    @NotBlank(message = "마스터 ID는 필수입니다")
    @Schema(description = "마스터 ID", example = "MASTER001")
    private String masterId;
    
    @NotBlank(message = "사용자 ID는 필수입니다")
    @Schema(description = "사용자 ID", example = "USER001")
    private String userId;
    
    @NotBlank(message = "비밀번호는 필수입니다")
    @Schema(description = "비밀번호")
    private String password;
}

// auth-service/src/main/java/com/ktds/rcsp/auth/dto/LoginResponse.java
package com.ktds.rcsp.auth.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
@Schema(description = "로그인 응답")
public class LoginResponse {
    @Schema(description = "액세스 토큰")
    private final String accessToken;
    
    @Schema(description = "리프레시 토큰")
    private final String refreshToken;
}

// auth-service/src/main/java/com/ktds/rcsp/auth/service/JwtTokenProvider.java
package com.ktds.rcsp.auth.service;

import io.jsonwebtoken.*;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import java.util.Date;

@Slf4j
@Component
public class JwtTokenProvider {

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${jwt.expiration}")
    private long jwtExpiration;

    public String createToken(String masterId, String userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpiration);

        return Jwts.builder()
                .setSubject(userId)
                .claim("masterId", masterId)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, jwtSecret)
                .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            log.error("JWT token validation error: {}", e.getMessage());
            return false;
        }
    }
}

// auth-service/src/main/java/com/ktds/rcsp/auth/service/AuthService.java
package com.ktds.rcsp.auth.service;

import com.ktds.rcsp.auth.dto.LoginRequest;
import com.ktds.rcsp.auth.dto.LoginResponse;
import org.springframework.validation.annotation.Validated;
import jakarta.validation.Valid;

@Validated
public interface AuthService {
    LoginResponse login(@Valid LoginRequest request);
    boolean verifyToken(String token);
}

// auth-service/src/main/java/com/ktds/rcsp/auth/service/AuthServiceImpl.java
package com.ktds.rcsp.auth.service;

import com.ktds.rcsp.auth.domain.User;
import com.ktds.rcsp.auth.dto.LoginRequest;
import com.ktds.rcsp.auth.dto.LoginResponse;
import com.ktds.rcsp.auth.repository.UserRepository;
import com.ktds.rcsp.common.exception.BusinessException;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class AuthServiceImpl implements AuthService {

    private final UserRepository userRepository;
    private final JwtTokenProvider jwtTokenProvider;
    private final PasswordEncoder passwordEncoder;

    @Override
    @Transactional
    public LoginResponse login(LoginRequest request) {
        User user = userRepository.findByMasterIdAndUserId(request.getMasterId(), request.getUserId())
                .orElseThrow(() -> new BusinessException("사용자 정보를 찾을 수 없습니다"));

        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new BusinessException("비밀번호가 일치하지 않습니다");
        }

        String accessToken = jwtTokenProvider.createToken(user.getMasterId(), user.getUserId());
        String refreshToken = jwtTokenProvider.createToken(user.getMasterId(), user.getUserId());

        return LoginResponse.builder()
                .accessToken(accessToken)
                .refreshToken(refreshToken)
                .build();
    }

    @Override
    public boolean verifyToken(String token) {
        return jwtTokenProvider.validateToken(token);
    }
}

// auth-service/src/main/java/com/ktds/rcsp/auth/controller/AuthController.java
package com.ktds.rcsp.auth.controller;

import com.ktds.rcsp.auth.dto.LoginRequest;
import com.ktds.rcsp.auth.dto.LoginResponse;
import com.ktds.rcsp.auth.service.AuthService;
import com.ktds.rcsp.common.dto.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@Tag(name = "인증", description = "인증 관련 API")
public class AuthController {

    private final AuthService authService;

    @PostMapping("/login")
    @Operation(summary = "로그인", description = "사용자 로그인을 처리합니다")
    public ApiResponse<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
        return ApiResponse.success(authService.login(request));
    }

    @GetMapping("/verify")
    @Operation(summary = "토큰 검증", description = "JWT 토큰의 유효성을 검증합니다")
    public ApiResponse<Boolean> verifyToken(@RequestParam String token) {
        return ApiResponse.success(authService.verifyToken(token));
    }
}

// message-service/src/main/java/com/ktds/rcsp/message/MessageServiceApplication.java
package com.ktds.rcsp.message;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = {"com.ktds.rcsp.message", "com.ktds.rcsp.common"})
public class MessageServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(MessageServiceApplication.class, args);
    }
}

// message-service/src/main/java/com/ktds/rcsp/message/domain/Message.java
package com.ktds.rcsp.message.domain;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "messages")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class Message {
    
    @Id
    private String messageId;
    
    @Column(name = "message_group_id", nullable = false)
    private String messageGroupId;
    
    @Column(name = "brand_id", nullable = false)
    private String brandId;
    
    @Column(name = "template_id", nullable = false)
    private String templateId;
    
    @Column(name = "chatbot_id", nullable = false)
    private String chatbotId;
    
    @Column(nullable = false, length = 4000)
    private String content;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private MessageStatus status;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    public void updateStatus(MessageStatus status) {
        this.status = status;
        this.updatedAt = LocalDateTime.now();
    }
}

// message-service/src/main/java/com/ktds/rcsp/message/domain/MessageStatus.java
package com.ktds.rcsp.message.domain;

public enum MessageStatus {
    PENDING,
    SENDING,
    SENT,
    FAILED
}

// message-service/src/main/java/com/ktds/rcsp/message/domain/ProcessingStatus.java
package com.ktds.rcsp.message.domain;

public enum ProcessingStatus {
    UPLOADING,
    PROCESSING,
    COMPLETED,
    FAILED
}

// message-service/src/main/java/com/ktds/rcsp/message/domain/Recipient.java
package com.ktds.rcsp.message.domain;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "recipients")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class Recipient {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "message_group_id", nullable = false)
    private String messageGroupId;
    
    @Column(name = "phone_number", nullable = false)
    private String phoneNumber;
    
    @Column(name = "encrypted_phone_number", nullable = false)
    private String encryptedPhoneNumber;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ProcessingStatus status;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
}

// message-service/src/main/java/com/ktds/rcsp/message/dto/MessageSendRequest.java
package com.ktds.rcsp.message.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Schema(description = "메시지 발송 요청")
public class MessageSendRequest {
   
   @NotBlank(message = "브랜드ID는 필수입니다")
   @Schema(description = "브랜드ID")
   private String brandId;
   
   @NotBlank(message = "템플릿ID는 필수입니다") 
   @Schema(description = "템플릿ID")
   private String templateId;
   
   @NotBlank(message = "발신번호ID는 필수입니다")
   @Schema(description = "발신번호ID")
   private String chatbotId;
   
   @NotBlank(message = "메시지그룹ID는 필수입니다")
   @Schema(description = "메시지그룹ID")
   private String messageGroupId;
   
   @NotBlank(message = "메시지 내용은 필수입니다")
   @Schema(description = "메시지 내용")
   private String content;
}

// message-service/src/main/java/com/ktds/rcsp/message/dto/MessageSendResponse.java
package com.ktds.rcsp.message.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
@Schema(description = "메시지 발송 응답")
public class MessageSendResponse {
   
   @Schema(description = "메시지그룹ID")
   private final String messageGroupId;
   
   @Schema(description = "상태")
   private final String status;
}

// message-service/src/main/java/com/ktds/rcsp/message/dto/RecipientUploadRequest.java
package com.ktds.rcsp.message.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Schema(description = "수신자 정보 업로드 요청")
public class RecipientUploadRequest {

   @Schema(description = "메시지그룹ID")
   private String messageGroupId;
}

// message-service/src/main/java/com/ktds/rcsp/message/dto/RecipientUploadResponse.java
package com.ktds.rcsp.message.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
@Schema(description = "수신자 정보 업로드 응답")
public class RecipientUploadResponse {
   
   @Schema(description = "메시지그룹ID")
   private final String messageGroupId;
   
   @Schema(description = "업로드 상태")
   private final boolean status;
}

// message-service/src/main/java/com/ktds/rcsp/message/dto/UploadProgressResponse.java
package com.ktds.rcsp.message.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
@Schema(description = "업로드 진행 상태 응답")
public class UploadProgressResponse {
   
   @Schema(description = "처리된 건수")
   private final int processedCount;
   
   @Schema(description = "성공 건수")
   private final int successCount;
   
   @Schema(description = "실패 건수")
   private final int failCount;
   
   @Schema(description = "전체 건수")
   private final int totalCount;
   
   @Schema(description = "처리 상태")
   private final String status;
}

// message-service/src/main/java/com/ktds/rcsp/message/repository/MessageRepository.java
package com.ktds.rcsp.message.repository;

import com.ktds.rcsp.message.domain.Message;
import org.springframework.data.jpa.repository.JpaRepository;

public interface MessageRepository extends JpaRepository<Message, String> {
}

// message-service/src/main/java/com/ktds/rcsp/message/repository/RecipientRepository.java
package com.ktds.rcsp.message.repository;

import com.ktds.rcsp.message.domain.Recipient;
import org.springframework.data.jpa.repository.JpaRepository;

public interface RecipientRepository extends JpaRepository<Recipient, Long> {
   long countByMessageGroupId(String messageGroupId);
   long countByMessageGroupIdAndStatus(String messageGroupId, String status);
}

// message-service/src/main/java/com/ktds/rcsp/message/service/MessageService.java
package com.ktds.rcsp.message.service;

import com.ktds.rcsp.message.dto.MessageSendRequest;
import com.ktds.rcsp.message.dto.MessageSendResponse;
import com.ktds.rcsp.message.dto.UploadProgressResponse;
import org.springframework.web.multipart.MultipartFile;

public interface MessageService {
   MessageSendResponse sendMessage(MessageSendRequest request);
   void uploadRecipients(String messageGroupId, MultipartFile file);
   void processMessageResult(String messageId, String status);
   UploadProgressResponse getUploadProgress(String messageGroupId);
}

// message-service/src/main/java/com/ktds/rcsp/message/service/MessageServiceImpl.java
package com.ktds.rcsp.message.service;

import com.ktds.rcsp.common.event.MessageSendEvent;
import com.ktds.rcsp.message.domain.Message;
import com.ktds.rcsp.message.domain.MessageStatus;
import com.ktds.rcsp.message.dto.MessageSendRequest;
import com.ktds.rcsp.message.dto.MessageSendResponse;
import com.ktds.rcsp.message.dto.UploadProgressResponse;
import com.ktds.rcsp.message.infra.EventHubMessagePublisher;
import com.ktds.rcsp.message.repository.MessageRepository;
import com.ktds.rcsp.message.repository.RecipientRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class MessageServiceImpl implements MessageService {

   private final MessageRepository messageRepository;
   private final RecipientRepository recipientRepository;
   private final EventHubMessagePublisher eventPublisher;
   private final RecipientService recipientService;

   @Override
   @Transactional
   public MessageSendResponse sendMessage(MessageSendRequest request) {
       Message message = Message.builder()
               .messageId(UUID.randomUUID().toString())
               .messageGroupId(request.getMessageGroupId())
               .brandId(request.getBrandId())
               .templateId(request.getTemplateId())
               .chatbotId(request.getChatbotId())
               .content(request.getContent())
               .status(MessageStatus.PENDING)
               .build();

       messageRepository.save(message);

       eventPublisher.publishMessageSendEvent(MessageSendEvent.builder()
               .messageId(message.getMessageId())
               .messageGroupId(message.getMessageGroupId())
               .content(message.getContent())
               .build());

       return MessageSendResponse.builder()
               .messageGroupId(message.getMessageGroupId())
               .status(message.getStatus().name())
               .build();
   }

   @Override
   @Transactional
   public void uploadRecipients(String messageGroupId, MultipartFile file) {
       try {
           recipientService.processRecipientFile(messageGroupId, file);
       } catch (Exception e) {
           log.error("Failed to upload recipients", e);
           throw new RuntimeException("Failed to upload recipients", e);
       }
   }

   @Override
   @Transactional
   public void processMessageResult(String messageId, String status) {
       Message message = messageRepository.findById(messageId)
               .orElseThrow(() -> new RuntimeException("Message not found"));
       
       message.updateStatus(MessageStatus.valueOf(status));
       messageRepository.save(message);
   }

   @Override
   @Transactional(readOnly = true)
   public UploadProgressResponse getUploadProgress(String messageGroupId) {
       long totalCount = recipientRepository.countByMessageGroupId(messageGroupId);
       long successCount = recipientRepository.countByMessageGroupIdAndStatus(messageGroupId, "COMPLETED");
       long failCount = recipientRepository.countByMessageGroupIdAndStatus(messageGroupId, "FAILED");
       
       return UploadProgressResponse.builder()
               .processedCount((int)(successCount + failCount))
               .successCount((int)successCount)
               .failCount((int)failCount)
               .totalCount((int)totalCount)
               .status(totalCount == (successCount + failCount) ? "COMPLETED" : "PROCESSING")
               .build();
   }
}

// message-service/src/main/java/com/ktds/rcsp/message/service/RecipientService.java
package com.ktds.rcsp.message.service;

import org.springframework.web.multipart.MultipartFile;

public interface RecipientService {
   void processRecipientFile(String messageGroupId, MultipartFile file);
   void encryptAndSaveRecipient(String messageGroupId, String phoneNumber);
}

// message-service/src/main/java/com/ktds/rcsp/message/service/RecipientServiceImpl.java
package com.ktds.rcsp.message.service;

import com.ktds.rcsp.common.event.RecipientUploadEvent;
import com.ktds.rcsp.message.domain.ProcessingStatus;
import com.ktds.rcsp.message.domain.Recipient;
import com.ktds.rcsp.message.infra.EncryptionService;
import com.ktds.rcsp.message.infra.EventHubMessagePublisher;
import com.ktds.rcsp.message.repository.RecipientRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;

@Slf4j
@Service
@RequiredArgsConstructor
public class RecipientServiceImpl implements RecipientService {

   private final RecipientRepository recipientRepository;
   private final EncryptionService encryptionService;
   private final EventHubMessagePublisher eventPublisher;

    @Async("recipientProcessorExecutor")
    @Override
    public void processRecipientFile(String messageGroupId, MultipartFile file) {
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {

            // 최신 CSVFormat 사용 방식
            CSVParser csvParser = CSVFormat.Builder.create()
                    .setHeader()
                    .setIgnoreHeaderCase(true)
                    .setTrim(true)
                    .setSkipHeaderRecord(true)
                    .build()
                    .parse(reader);

            int totalCount = 0;
            for (CSVRecord record : csvParser) {
                String phoneNumber = record.get("phoneNumber");
                encryptAndSaveRecipient(messageGroupId, phoneNumber);
                totalCount++;
            }

            eventPublisher.publishUploadEvent(RecipientUploadEvent.builder()
                    .messageGroupId(messageGroupId)
                    .fileName(file.getOriginalFilename())
                    .totalCount(totalCount)
                    .build());

        } catch (Exception e) {
            log.error("Error processing recipient file", e);
            throw new RuntimeException("Failed to process recipient file", e);
        }
    }

   @Override
   @Transactional
   public void encryptAndSaveRecipient(String messageGroupId, String phoneNumber) {
       try {
           String encryptedPhoneNumber = encryptionService.encrypt(phoneNumber);
           
           Recipient recipient = Recipient.builder()
                   .messageGroupId(messageGroupId)
                   .phoneNumber(phoneNumber)
                   .encryptedPhoneNumber(encryptedPhoneNumber)
                   .status(ProcessingStatus.COMPLETED)
                   .build();

           recipientRepository.save(recipient);
       } catch (Exception e) {
           log.error("Failed to encrypt and save recipient", e);
           throw new RuntimeException("Failed to encrypt and save recipient", e);
       }
   }
}

// message-service/src/main/java/com/ktds/rcsp/message/controller/MessageController.java
package com.ktds.rcsp.message.controller;

import com.ktds.rcsp.common.dto.ApiResponse;
import com.ktds.rcsp.message.dto.MessageSendRequest;
import com.ktds.rcsp.message.dto.MessageSendResponse;
import com.ktds.rcsp.message.dto.UploadProgressResponse;
import com.ktds.rcsp.message.service.MessageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequestMapping("/api/messages")
@RequiredArgsConstructor
@Tag(name = "메시지", description = "메시지 발송 관련 API")
public class MessageController {

   private final MessageService messageService;

   @PostMapping("/send")
   @Operation(summary = "메시지 발송", description = "RCS 메시지를 발송합니다")
   public ApiResponse<MessageSendResponse> sendMessage(@Valid @RequestBody MessageSendRequest request) {
       return ApiResponse.success(messageService.sendMessage(request));
   }

   @PostMapping("/recipients/upload")
   @Operation(summary = "수신자 정보 업로드", description = "수신자 정보 파일을 업로드합니다")
   public ApiResponse<Void> uploadRecipients(
           @RequestParam String messageGroupId,
           @RequestParam("file") MultipartFile file) {
       messageService.uploadRecipients(messageGroupId, file);
       return ApiResponse.success(null);
   }

   @GetMapping("/recipients/status")
   @Operation(summary = "업로드 진행 상태 조회", description = "수신자 정보 업로드 진행 상태를 조회합니다")
   public ApiResponse<UploadProgressResponse> getUploadProgress(
           @RequestParam String messageGroupId) {
       return ApiResponse.success(messageService.getUploadProgress(messageGroupId));
   }
}

// message-service/src/main/java/com/ktds/rcsp/message/infra/EncryptionService.java
package com.ktds.rcsp.message.infra;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Slf4j
@Component
public class EncryptionService {

   @Value("${encryption.key}")
   private String encryptionKey;

   private static final String ALGORITHM = "AES";

   public String encrypt(String data) {
       try {
           SecretKeySpec keySpec = new SecretKeySpec(
               encryptionKey.getBytes(StandardCharsets.UTF_8), ALGORITHM);
           Cipher cipher = Cipher.getInstance(ALGORITHM);
           cipher.init(Cipher.ENCRYPT_MODE, keySpec);
           
           byte[] encrypted = cipher.doFinal(data.getBytes());
           return Base64.getEncoder().encodeToString(encrypted);
       } catch (Exception e) {
           log.error("Encryption failed", e);
           throw new RuntimeException("Encryption failed", e);
       }
   }

   public String decrypt(String encryptedData) {
       try {
           SecretKeySpec keySpec = new SecretKeySpec(
               encryptionKey.getBytes(StandardCharsets.UTF_8), ALGORITHM);
           Cipher cipher = Cipher.getInstance(ALGORITHM);
           cipher.init(Cipher.DECRYPT_MODE, keySpec);
           
           byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(encryptedData));
           return new String(decrypted);
       } catch (Exception e) {
           log.error("Decryption failed", e);
           throw new RuntimeException("Decryption failed", e);
       }
   }
}

// message-service/src/main/java/com/ktds/rcsp/message/infra/EventHubMessagePublisher.java
package com.ktds.rcsp.message.infra;

import com.azure.messaging.eventhubs.EventData;
import com.azure.messaging.eventhubs.EventHubProducerClient;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.ktds.rcsp.common.event.MessageSendEvent;
import com.ktds.rcsp.common.event.RecipientUploadEvent;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.List;

@Slf4j
@Component
@RequiredArgsConstructor
public class EventHubMessagePublisher {

   private final EventHubProducerClient producerClient;
   private final ObjectMapper objectMapper;

   public void publishMessageSendEvent(MessageSendEvent event) {
       try {
           String eventData = objectMapper.writeValueAsString(event);
           producerClient.send(EventData.create(eventData.getBytes()));
           log.info("Published message send event: {}", event.getMessageId());
       } catch (Exception e) {
           log.error("Error publishing message send event", e);
           throw new RuntimeException("Failed to publish message send event", e);
       }
   }

    public void publishUploadEvent(RecipientUploadEvent event) {
        try {
            String eventData = objectMapper.writeValueAsString(event);
            EventData eventDataObj = new EventData(eventData.getBytes());

            // EventData를 List로 감싸서 전송
            List<EventData> events = Collections.singletonList(eventDataObj);
            producerClient.send(events);

            log.info("Published recipient upload event: {}", event.getMessageGroupId());
        } catch (Exception e) {
            log.error("Error publishing recipient upload event", e);
            throw new RuntimeException("Failed to publish recipient upload event", e);
        }
    }
}

// message-service/src/main/java/com/ktds/rcsp/message/infra/EventHubMessageSubscriber.java
package com.ktds.rcsp.message.infra;

import com.azure.messaging.eventhubs.EventData;
import com.azure.messaging.eventhubs.EventHubConsumerClient;
import com.azure.messaging.eventhubs.models.EventPosition;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.ktds.rcsp.common.event.MessageResultEvent;
import com.ktds.rcsp.message.service.MessageService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import javax.annotation.PostConstruct;

@Slf4j
@Component
@RequiredArgsConstructor
public class EventHubMessageSubscriber {
    
    private final EventHubConsumerClient consumerClient;
    private final ObjectMapper objectMapper;
    private final MessageService messageService;

    @PostConstruct
    public void subscribe() {
        startMessageResultSubscription();
    }

    @Async("eventHubExecutor")
    public void startMessageResultSubscription() {
        consumerClient.receive(false)
            .subscribe(partitionEvent -> {
                try {
                    EventData eventData = partitionEvent.getData();
                    String eventBody = new String(eventData.getBody());
                    MessageResultEvent event = objectMapper.readValue(eventBody, MessageResultEvent.class);
                    
                    log.info("Received message result event: {}", event.getMessageId());
                    messageService.processMessageResult(
                        event.getMessageId(), 
                        event.getStatus()
                    );
                } catch (Exception e) {
                    log.error("Error processing message result event", e);
                }
            }, error -> {
                log.error("Error in event subscription", error);
                // 재시도 로직 구현
                startMessageResultSubscription();
            });
    }
}


// message-service/src/main/java/com/ktds/rcsp/message/infra/config/EventHubConfig.java
package com.ktds.rcsp.message.infra.config;

import com.azure.messaging.eventhubs.EventHubClientBuilder;
import com.azure.messaging.eventhubs.EventHubProducerClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class EventHubConfig {
   
   @Value("${azure.eventhub.connection-string}")
   private String connectionString;
   
   @Value("${azure.eventhub.name}")
   private String eventHubName;
   
   @Bean
   public EventHubProducerClient eventHubProducerClient() {
       return new EventHubClientBuilder()
               .connectionString(connectionString, eventHubName)
               .buildProducerClient();
   }

   @Bean
public EventHubConsumerClient eventHubConsumerClient() {
    return new EventHubClientBuilder()
        .connectionString(connectionString, eventHubName)
        .consumerGroup(EventHubClientBuilder.DEFAULT_CONSUMER_GROUP_NAME)
        .buildConsumerClient();
}
}

// history-service/src/main/java/com/ktds/rcsp/history/HistoryServiceApplication.java
package com.ktds.rcsp.history;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = {"com.ktds.rcsp.history", "com.ktds.rcsp.common"})
public class HistoryServiceApplication {
   public static void main(String[] args) {
       SpringApplication.run(HistoryServiceApplication.class, args);
   }
}

// history-service/src/main/java/com/ktds/rcsp/history/domain/MessageHistory.java
package com.ktds.rcsp.history.domain;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "message_history")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class MessageHistory {
   
   @Id
   private String messageId;
   
   @Column(name = "message_group_id", nullable = false)
   private String messageGroupId;
   
   @Column(name = "master_id", nullable = false)
   private String masterId;
   
   @Column(name = "brand_id", nullable = false)
   private String brandId;
   
   @Column(name = "template_id", nullable = false)
   private String templateId;
   
   @Column(name = "chatbot_id", nullable = false)
   private String chatbotId;
   
   @Column(nullable = false, length = 4000)
   private String content;
   
   @Enumerated(EnumType.STRING)
   @Column(nullable = false)
   private MessageStatus status;
   
   @Column(name = "result_code")
   private String resultCode;
   
   @Column(name = "result_message")
   private String resultMessage;
   
   @Column(name = "created_at", nullable = false)
   private LocalDateTime createdAt;
   
   @Column(name = "updated_at")
   private LocalDateTime updatedAt;

   public void updateStatus(MessageStatus status, String resultCode, String resultMessage) {
       this.status = status;
       this.resultCode = resultCode;
       this.resultMessage = resultMessage;
       this.updatedAt = LocalDateTime.now();
   }
}

// history-service/src/main/java/com/ktds/rcsp/history/domain/MessageStatus.java
package com.ktds.rcsp.history.domain;

public enum MessageStatus {
   PENDING,
   SENDING,
   SENT,
   FAILED
}

// history-service/src/main/java/com/ktds/rcsp/history/dto/MessageHistorySearchRequest.java
package com.ktds.rcsp.history.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Getter;
import lombok.Setter;
import java.time.LocalDateTime;

@Getter
@Setter
@Schema(description = "메시지 이력 검색 요청")
public class MessageHistorySearchRequest {
   
   @Schema(description = "시작일시")
   private LocalDateTime startDate;
   
   @Schema(description = "종료일시")
   private LocalDateTime endDate;
   
   @Schema(description = "브랜드ID")
   private String brandId;
   
   @Schema(description = "발신번호ID")
   private String chatbotId;
   
   @Schema(description = "메시지그룹ID")
   private String messageGroupId;
   
   @Schema(description = "상태")
   private String status;
   
   @Schema(description = "페이지 번호")
   private int page;
   
   @Schema(description = "페이지 크기")
   private int size;
}


// history-service/src/main/java/com/ktds/rcsp/history/dto/MessageHistoryResponse.java
package com.ktds.rcsp.history.dto;

import com.ktds.rcsp.history.domain.MessageStatus;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Builder;
import lombok.Getter;
import java.time.LocalDateTime;

@Getter
@Builder
@Schema(description = "메시지 이력 응답")
public class MessageHistoryResponse {
   
   @Schema(description = "메시지ID")
   private final String messageId;
   
   @Schema(description = "메시지그룹ID")
   private final String messageGroupId;
   
   @Schema(description = "브랜드ID")
   private final String brandId;
   
   @Schema(description = "템플릿ID")
   private final String templateId;
   
   @Schema(description = "발신번호ID")
   private final String chatbotId;
   
   @Schema(description = "메시지 내용")
   private final String content;
   
   @Schema(description = "상태")
   private final MessageStatus status;
   
   @Schema(description = "결과 코드")
   private final String resultCode;
   
   @Schema(description = "결과 메시지")
   private final String resultMessage;
   
   @Schema(description = "생성일시")
   private final LocalDateTime createdAt;
   
   @Schema(description = "수정일시")
   private final LocalDateTime updatedAt;
}

// history-service/src/main/java/com/ktds/rcsp/history/dto/SortRequest.java
package com.ktds.rcsp.history.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Schema(description = "정렬 요청")
public class SortRequest {
   
   @Schema(description = "정렬 필드")
   private String field;
   
   @Schema(description = "정렬 방향")
   private String direction;
}

// history-service/src/main/java/com/ktds/rcsp/history/repository/HistoryRepository.java
package com.ktds.rcsp.history.repository;

import com.ktds.rcsp.history.domain.MessageHistory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

public interface HistoryRepository extends JpaRepository<MessageHistory, String>, 
                                       JpaSpecificationExecutor<MessageHistory> {
}

// history-service/src/main/java/com/ktds/rcsp/history/repository/MessageHistorySpecification.java
package com.ktds.rcsp.history.repository;

import com.ktds.rcsp.history.domain.MessageHistory;
import com.ktds.rcsp.history.domain.MessageStatus;
import com.ktds.rcsp.history.dto.MessageHistorySearchRequest;
import org.springframework.data.jpa.domain.Specification;
import java.util.ArrayList;
import java.util.List;
import jakarta.persistence.criteria.Predicate;

public class MessageHistorySpecification {

   public static Specification<MessageHistory> searchMessageHistory(MessageHistorySearchRequest request) {
       return (root, query, criteriaBuilder) -> {
           List<Predicate> predicates = new ArrayList<>();

           if (request.getStartDate() != null && request.getEndDate() != null) {
               predicates.add(criteriaBuilder.between(root.get("createdAt"), 
                   request.getStartDate(), request.getEndDate()));
           }

           if (request.getBrandId() != null) {
               predicates.add(criteriaBuilder.equal(root.get("brandId"), request.getBrandId()));
           }

           if (request.getChatbotId() != null) {
               predicates.add(criteriaBuilder.equal(root.get("chatbotId"), request.getChatbotId()));
           }

           if (request.getMessageGroupId() != null) {
               predicates.add(criteriaBuilder.equal(root.get("messageGroupId"), 
                   request.getMessageGroupId()));
           }

           if (request.getStatus() != null) {
               predicates.add(criteriaBuilder.equal(root.get("status"), 
                   MessageStatus.valueOf(request.getStatus())));
           }

           return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
       };
   }
}


// history-service/src/main/java/com/ktds/rcsp/history/service/HistoryService.java
package com.ktds.rcsp.history.service;

import com.ktds.rcsp.common.dto.PageResponse;
import com.ktds.rcsp.history.dto.MessageHistorySearchRequest;
import com.ktds.rcsp.history.dto.MessageHistoryResponse;

public interface HistoryService {
   PageResponse<MessageHistoryResponse> searchMessages(MessageHistorySearchRequest request);
   MessageHistoryResponse saveMessageHistory(MessageHistoryResponse history);
   void updateMessageStatus(String messageId, String status, String resultCode, String resultMessage);
}

// history-service/src/main/java/com/ktds/rcsp/history/service/HistoryServiceImpl.java
package com.ktds.rcsp.history.service;

import com.ktds.rcsp.common.dto.PageResponse;
import com.ktds.rcsp.history.domain.MessageHistory;
import com.ktds.rcsp.history.domain.MessageStatus;
import com.ktds.rcsp.history.dto.MessageHistoryResponse;
import com.ktds.rcsp.history.dto.MessageHistorySearchRequest;
import com.ktds.rcsp.history.repository.HistoryRepository;
import com.ktds.rcsp.history.repository.MessageHistorySpecification;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.cache.annotation.CacheEvict;

@Service
@RequiredArgsConstructor
public class HistoryServiceImpl implements HistoryService {

   private final HistoryRepository historyRepository;

   @Override
   @Transactional(readOnly = true)
   public PageResponse<MessageHistoryResponse> searchMessages(MessageHistorySearchRequest request) {
       Page<MessageHistory> page = historyRepository.findAll(
           MessageHistorySpecification.searchMessageHistory(request),
           PageRequest.of(request.getPage(), request.getSize())
       );

       return PageResponse.<MessageHistoryResponse>builder()
               .content(page.getContent().stream()
                       .map(this::convertToResponse)
                       .toList())
               .totalElements(page.getTotalElements())
               .totalPages(page.getTotalPages())
               .pageNumber(page.getNumber())
               .pageSize(page.getSize())
               .build();
   }

   @Override
   @Transactional
   @CacheEvict(value = "messageHistory", key = "#history.messageId")
   public MessageHistoryResponse saveMessageHistory(MessageHistoryResponse history) {
       MessageHistory entity = convertToEntity(history);
       MessageHistory savedEntity = historyRepository.save(entity);
       return convertToResponse(savedEntity);
   }

   @Override
   @Transactional
   @CacheEvict(value = "messageHistory", key = "#messageId")
   public void updateMessageStatus(String messageId, String status, String resultCode, String resultMessage) {
       MessageHistory history = historyRepository.findById(messageId)
               .orElseThrow(() -> new RuntimeException("Message history not found: " + messageId));
           
       history.updateStatus(MessageStatus.valueOf(status), resultCode, resultMessage);
       historyRepository.save(history);
   }

   @Cacheable(value = "messageHistory", key = "#messageId")
   public MessageHistoryResponse getMessageHistory(String messageId) {
       return historyRepository.findById(messageId)
               .map(this::convertToResponse)
               .orElseThrow(() -> new RuntimeException("Message history not found: " + messageId));
   }

   private MessageHistoryResponse convertToResponse(MessageHistory entity) {
       return MessageHistoryResponse.builder()
               .messageId(entity.getMessageId())
               .messageGroupId(entity.getMessageGroupId())
               .brandId(entity.getBrandId())
               .templateId(entity.getTemplateId())
               .chatbotId(entity.getChatbotId())
               .content(entity.getContent())
               .status(entity.getStatus())
               .resultCode(entity.getResultCode())
               .resultMessage(entity.getResultMessage())
               .createdAt(entity.getCreatedAt())
               .updatedAt(entity.getUpdatedAt())
               .build();
   }

   private MessageHistory convertToEntity(MessageHistoryResponse dto) {
       return MessageHistory.builder()
               .messageId(dto.getMessageId())
               .messageGroupId(dto.getMessageGroupId())
               .brandId(dto.getBrandId())
               .templateId(dto.getTemplateId())
               .chatbotId(dto.getChatbotId())
               .content(dto.getContent())
               .status(dto.getStatus())
               .resultCode(dto.getResultCode())
               .resultMessage(dto.getResultMessage())
               .createdAt(dto.getCreatedAt())
               .updatedAt(dto.getUpdatedAt())
               .build();
   }
}


// history-service/src/main/java/com/ktds/rcsp/history/controller/HistoryController.java
package com.ktds.rcsp.history.controller;

import com.ktds.rcsp.common.dto.ApiResponse;
import com.ktds.rcsp.common.dto.PageResponse;
import com.ktds.rcsp.history.dto.MessageHistoryResponse;
import com.ktds.rcsp.history.dto.MessageHistorySearchRequest;
import com.ktds.rcsp.history.service.HistoryService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/history")
@RequiredArgsConstructor
@Tag(name = "이력조회", description = "메시지 발송 이력 조회 API")
public class HistoryController {

   private final HistoryService historyService;

   @PostMapping("/messages/search")
   @Operation(summary = "메시지 이력 검색", description = "메시지 발송 이력을 검색합니다")
   public ApiResponse<PageResponse<MessageHistoryResponse>> searchMessages(
           @RequestBody MessageHistorySearchRequest request) {
       return ApiResponse.success(historyService.searchMessages(request));
   }

   @PostMapping("/messages/{messageId}/status")
   @Operation(summary = "메시지 상태 업데이트", description = "메시지 발송 상태를 업데이트합니다")
   public ApiResponse<Void> updateMessageStatus(
           @PathVariable String messageId,
           @RequestParam String status,
           @RequestParam(required = false) String resultCode,
           @RequestParam(required = false) String resultMessage) {
       historyService.updateMessageStatus(messageId, status, resultCode, resultMessage);
       return ApiResponse.success(null);
   }
}

// history-service/src/main/java/com/ktds/rcsp/history/config/CacheConfig.java
package com.ktds.rcsp.history.config;

import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableCaching
public class CacheConfig {
   
   @Bean
   public CacheManager cacheManager() {
       return new ConcurrentMapCacheManager("messageHistory");
   }
}

// history-service/src/main/java/com/ktds/rcsp/history/config/AsyncConfig.java
package com.ktds.rcsp.history.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

@Configuration
@EnableAsync
public class AsyncConfig {
   
   @Bean(name = "historyTaskExecutor")
   public ThreadPoolTaskExecutor taskExecutor() {
       ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
       executor.setCorePoolSize(5);
       executor.setMaxPoolSize(10);
       executor.setQueueCapacity(25);
       executor.setThreadNamePrefix("History-");
       executor.initialize();
       return executor;
   }
}

// history-service/src/main/java/com/ktds/rcsp/history/event/MessageEventListener.java
package com.ktds.rcsp.history.event;

import com.ktds.rcsp.common.event.MessageSendEvent;
import com.ktds.rcsp.history.service.HistoryService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.springframework.transaction.event.TransactionalEventListener;

@Slf4j
@Component
@RequiredArgsConstructor
public class MessageEventListener {

   private final HistoryService historyService;

   @Async("historyTaskExecutor")
   @TransactionalEventListener
   public void handleMessageSendEvent(MessageSendEvent event) {
       try {
           // 이력 저장 로직
           log.info("Received message send event: {}", event.getMessageId());
       } catch (Exception e) {
           log.error("Failed to handle message send event", e);
       }
   }
}


// basedata-service/src/main/java/com/ktds/rcsp/basedata/BaseDataServiceApplication.java
package com.ktds.rcsp.basedata;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = {"com.ktds.rcsp.basedata", "com.ktds.rcsp.common"})
public class BaseDataServiceApplication {
   public static void main(String[] args) {
       SpringApplication.run(BaseDataServiceApplication.class, args);
   }
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/domain/Brand.java
package com.ktds.rcsp.basedata.domain;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "brands")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class Brand {
   
   @Id
   @Column(name = "brand_id")
   private String brandId;
   
   @Column(name = "master_id", nullable = false)
   private String masterId;
   
   @Column(name = "brand_name", nullable = false)
   private String brandName;
   
   @Column(nullable = false)
   private String status;
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/domain/Template.java
package com.ktds.rcsp.basedata.domain;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "templates")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class Template {
   
   @Id
   @Column(name = "template_id")
   private String templateId;
   
   @Column(name = "brand_id", nullable = false)
   private String brandId;
   
   @Column(name = "template_name", nullable = false)
   private String templateName;
   
   @Column(nullable = false, length = 4000)
   private String content;
   
   @Column(nullable = false)
   private String status;
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/domain/Chatbot.java
package com.ktds.rcsp.basedata.domain;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "chatbots")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class Chatbot {
   
   @Id
   @Column(name = "chatbot_id")
   private String chatbotId;
   
   @Column(name = "brand_id", nullable = false)
   private String brandId;
   
   @Column(name = "phone_number", nullable = false)
   private String phoneNumber;
   
   @Column(nullable = false)
   private String status;
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/dto/BrandResponse.java
package com.ktds.rcsp.basedata.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
@Schema(description = "브랜드 응답")
public class BrandResponse {
   
   @Schema(description = "브랜드ID")
   private final String brandId;
   
   @Schema(description = "브랜드명")
   private final String brandName;
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/dto/TemplateResponse.java
package com.ktds.rcsp.basedata.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
@Schema(description = "템플릿 응답")
public class TemplateResponse {
   
   @Schema(description = "템플릿ID")
   private final String templateId;
   
   @Schema(description = "템플릿명")
   private final String templateName;
   
   @Schema(description = "템플릿 내용")
   private final String content;
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/dto/ChatbotResponse.java
package com.ktds.rcsp.basedata.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
@Schema(description = "발신번호 응답")
public class ChatbotResponse {
   
   @Schema(description = "발신번호ID")
   private final String chatbotId;
   
   @Schema(description = "전화번호")
   private final String phoneNumber;
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/repository/BrandRepository.java
package com.ktds.rcsp.basedata.repository;

import com.ktds.rcsp.basedata.domain.Brand;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface BrandRepository extends JpaRepository<Brand, String> {
   List<Brand> findByMasterIdAndStatus(String masterId, String status);
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/repository/TemplateRepository.java
package com.ktds.rcsp.basedata.repository;

import com.ktds.rcsp.basedata.domain.Template;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface TemplateRepository extends JpaRepository<Template, String> {
   List<Template> findByBrandIdAndStatus(String brandId, String status);
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/repository/ChatbotRepository.java
package com.ktds.rcsp.basedata.repository;

import com.ktds.rcsp.basedata.domain.Chatbot;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface ChatbotRepository extends JpaRepository<Chatbot, String> {
   List<Chatbot> findByBrandIdAndStatus(String brandId, String status);
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/service/BaseDataService.java
package com.ktds.rcsp.basedata.service;

import com.ktds.rcsp.basedata.dto.BrandResponse;
import com.ktds.rcsp.basedata.dto.TemplateResponse;
import com.ktds.rcsp.basedata.dto.ChatbotResponse;
import java.util.List;

public interface BaseDataService {
   List<BrandResponse> getBrands(String masterId);
   List<TemplateResponse> getTemplates(String brandId);
   List<ChatbotResponse> getChatbots(String brandId);
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/service/BaseDataServiceImpl.java
package com.ktds.rcsp.basedata.service;

import com.ktds.rcsp.basedata.domain.Brand;
import com.ktds.rcsp.basedata.domain.Template;
import com.ktds.rcsp.basedata.domain.Chatbot;
import com.ktds.rcsp.basedata.dto.BrandResponse;
import com.ktds.rcsp.basedata.dto.TemplateResponse;
import com.ktds.rcsp.basedata.dto.ChatbotResponse;
import com.ktds.rcsp.basedata.repository.BrandRepository;
import com.ktds.rcsp.basedata.repository.TemplateRepository;
import com.ktds.rcsp.basedata.repository.ChatbotRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class BaseDataServiceImpl implements BaseDataService {

   private final BrandRepository brandRepository;
   private final TemplateRepository templateRepository;
   private final ChatbotRepository chatbotRepository;

   private static final String ACTIVE_STATUS = "ACTIVE";

   @Override
   @Transactional(readOnly = true)
   @Cacheable(value = "brands", key = "#masterId")
   public List<BrandResponse> getBrands(String masterId) {
       return brandRepository.findByMasterIdAndStatus(masterId, ACTIVE_STATUS)
               .stream()
               .map(this::convertToBrandResponse)
               .collect(Collectors.toList());
   }

   @Override
   @Transactional(readOnly = true)
   @Cacheable(value = "templates", key = "#brandId")
   public List<TemplateResponse> getTemplates(String brandId) {
       return templateRepository.findByBrandIdAndStatus(brandId, ACTIVE_STATUS)
               .stream()
               .map(this::convertToTemplateResponse)
               .collect(Collectors.toList());
   }

   @Override
   @Transactional(readOnly = true)
   @Cacheable(value = "chatbots", key = "#brandId")
   public List<ChatbotResponse> getChatbots(String brandId) {
       return chatbotRepository.findByBrandIdAndStatus(brandId, ACTIVE_STATUS)
               .stream()
               .map(this::convertToChatbotResponse)
               .collect(Collectors.toList());
   }

   private BrandResponse convertToBrandResponse(Brand brand) {
       return BrandResponse.builder()
               .brandId(brand.getBrandId())
               .brandName(brand.getBrandName())
               .build();
   }

   private TemplateResponse convertToTemplateResponse(Template template) {
       return TemplateResponse.builder()
               .templateId(template.getTemplateId())
               .templateName(template.getTemplateName())
               .content(template.getContent())
               .build();
   }

   private ChatbotResponse convertToChatbotResponse(Chatbot chatbot) {
       return ChatbotResponse.builder()
               .chatbotId(chatbot.getChatbotId())
               .phoneNumber(chatbot.getPhoneNumber())
               .build();
   }
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/controller/BaseDataController.java
package com.ktds.rcsp.basedata.controller;

import com.ktds.rcsp.basedata.dto.BrandResponse;
import com.ktds.rcsp.basedata.dto.TemplateResponse;
import com.ktds.rcsp.basedata.dto.ChatbotResponse;
import com.ktds.rcsp.basedata.service.BaseDataService;
import com.ktds.rcsp.common.dto.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/base")
@RequiredArgsConstructor
@Tag(name = "기준정보", description = "기준정보 조회 API")
public class BaseDataController {

   private final BaseDataService baseDataService;

   @GetMapping("/brands")
   @Operation(summary = "브랜드 목록 조회", description = "기업의 브랜드 목록을 조회합니다")
   public ApiResponse<List<BrandResponse>> getBrands(@RequestParam String masterId) {
       return ApiResponse.success(baseDataService.getBrands(masterId));
   }

   @GetMapping("/templates")
   @Operation(summary = "템플릿 목록 조회", description = "브랜드의 템플릿 목록을 조회합니다")
   public ApiResponse<List<TemplateResponse>> getTemplates(@RequestParam String brandId) {
       return ApiResponse.success(baseDataService.getTemplates(brandId));
   }

   @GetMapping("/chatbots")
   @Operation(summary = "발신번호 목록 조회", description = "브랜드의 발신번호 목록을 조회합니다")
   public ApiResponse<List<ChatbotResponse>> getChatbots(@RequestParam String brandId) {
       return ApiResponse.success(baseDataService.getChatbots(brandId));
   }
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/config/CacheConfig.java
package com.ktds.rcsp.basedata.config;

import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableCaching
public class CacheConfig {
   
   @Bean
   public CacheManager cacheManager() {
       return new ConcurrentMapCacheManager("brands", "templates", "chatbots");
   }
}

// basedata-service/src/main/java/com/ktds/rcsp/basedata/config/SecurityConfig.java
package com.ktds.rcsp.basedata.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

   @Bean
   public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       http
           .csrf(csrf -> csrf.disable())
           .authorizeHttpRequests(auth -> auth
               .requestMatchers("/swagger-ui/**", "/api-docs/**").permitAll()
               .requestMatchers("/actuator/**").permitAll()
               .anyRequest().authenticated()
           )
           .oauth2ResourceServer(oauth2 -> oauth2.jwt(jwt -> {}));
       
       return http.build();
   }
}








